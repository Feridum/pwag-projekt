#version 410 core

// define the number of CPs in the output patch
//layout(vertices = 3) out;
layout(vertices = 25) out;

in vec2 TexGeoCoord_CS_in[];
//in vec3 HouseCoord_CS_in_F[gl_MaxPatchVertices];
//in vec4 HouseCoord_CS_in_S[gl_MaxPatchVertices];

out vec2 TexGeoCoord_ES_in[];
//out vec4 HouseCoord_ES_in[];
out float houseX_ES_in[];
out float houseY_ES_in[];
out vec4 posA_ES_in[];

uniform int houseNum;
//uniform int seedV;
uniform float wallLength;
uniform float randoms1;
uniform float randoms2;

void main()
{
    // Set the control points of the output patch
    TexGeoCoord_ES_in[gl_InvocationID] = TexGeoCoord_CS_in[gl_InvocationID];

    /*
    if (gl_InvocationID == 0){
        gl_TessLevelInner[0] = 10.0;
        gl_TessLevelOuter[0] = 10.0;
        gl_TessLevelOuter[1] = 10.0;
        gl_TessLevelOuter[2] = 10.0;
    }
    */
    if (gl_InvocationID == 0)
    {
       gl_TessLevelInner[0] = 4.0;
       gl_TessLevelInner[1] = 4.0;
       gl_TessLevelOuter[0] = 5.0;
       gl_TessLevelOuter[1] = 5.0;
       gl_TessLevelOuter[2] = 5.0;
       gl_TessLevelOuter[3] = 5.0;

       //srand(seedV);
       vec4 posA = vec4(0.0, 0.0, 0.0, 1.0);
       posA.x = gl_in[gl_InvocationID].gl_Position.x + 1.0;     //+/-  ?    
       posA.y = gl_in[gl_InvocationID].gl_Position.y + 1.0;     //+/-  ?    
       posA.z = gl_in[gl_InvocationID].gl_Position.z;

       posA_ES_in[gl_InvocationID] = posA;
       float houseX;
       float houseY;

       houseX = randoms1;
       houseX = (houseX <= 0.25 ? 0.25 : houseX);
       houseX_ES_in[gl_InvocationID] = houseX * wallLength;

       houseY = randoms2;
       houseY = (houseY <= 0.2 ? 0.2 : houseY);
       houseY_ES_in[gl_InvocationID] = houseY * wallLength;
    }

    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;// + (10*houseNum)].gl_Position = gl_in[gl_InvocationID].gl_Position;
    //if (gl_InvocationID%25 == 0)
    //{
        //
    //}

}







    /*
    float houseX, houseY, houseWallH;
    vec4 posA, posB, posBp, posC, posCp, posD, posDp, posE, posEp, posF, posFp;

    //============================
    //na ka¿dy domek wysy³amy dalej wszystkie wymagane wierzcho³ki. Oznacza to, ¿e potrzebnych ich jest 10 - bez punktu centalnego domu. W tym miejscu z niego korzystamy i nie ma sensu go dalej przekazywaæ
    for(int i = 0; i < houseNum; i++)
    {
        posA = vec4(HouseCoord_CS_in_F[i].x, HouseCoord_CS_in_F[i].y, HouseCoord_CS_in_F[i].z, 1.0);
        posB = vec4(HouseCoord_CS_in_S[i].x, HouseCoord_CS_in_S[i].y, HouseCoord_CS_in_S[i].z, 1.0);

        houseX = posA.x-posB.x;
	    houseY = posA.y-posB.y;
        houseWallH = HouseCoord_CS_in_S[i].w;

        posBp = vec4(posA.x - houseX, posA.y - houseY, posA.z, 1.0);
        posC = vec4(posA.x - houseX, posB.y, posA.z, 1.0);
        posCp = vec4(posB.x, posA.y - houseY, posA.z, 1.0);

        posD = vec4(posB.x, posB.y, posB.z + houseWallH, 1.0);
        posDp = vec4(posBp.x, posBp.y, posBp.z + houseWallH, 1.0);
        posE = vec4(posC.x, posC.y, posC.z + houseWallH, 1.0);
        posEp = vec4(posCp.x, posCp.y, posCp.z + houseWallH, 1.0);

        posF = vec4(posA.x, posB.y, posA.z + 1.5*houseWallH, 1.0);
        posFp = vec4(posA.x, posBp.y, posA.z + 1.5*houseWallH, 1.0);

        gl_out[gl_InvocationID + (10*i) + 0].gl_Position = posB;
        gl_out[gl_InvocationID + (10*i) + 1].gl_Position = posBp;
        gl_out[gl_InvocationID + (10*i) + 2].gl_Position = posC;
        gl_out[gl_InvocationID + (10*i) + 3].gl_Position = posCp;
        gl_out[gl_InvocationID + (10*i) + 4].gl_Position = posD;
        gl_out[gl_InvocationID + (10*i) + 5].gl_Position = posDp;
        gl_out[gl_InvocationID + (10*i) + 6].gl_Position = posE;
        gl_out[gl_InvocationID + (10*i) + 7].gl_Position = posEp;
        gl_out[gl_InvocationID + (10*i) + 8].gl_Position = posF;
        gl_out[gl_InvocationID + (10*i) + 9].gl_Position = posFp;
    }
    */