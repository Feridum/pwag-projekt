#version 410 core

// define the number of CPs in the output patch
layout(vertices = 3) out;

in vec2 TexGeoCoord_CS_in[];
in vec3 HouseCoord_CS_in_F[gl_MaxPatchVertices];
in vec4 HouseCoord_CS_in_S[gl_MaxPatchVertices];

out vec2 TexGeoCoord_ES_in[];
out vec3 HouseCoord_ES_in[];

uniform int houseNum;

void main()
{
    // Set the control points of the output patch
    TexGeoCoord_ES_in[gl_InvocationID] = TexGeoCoord_CS_in[gl_InvocationID];

    if (gl_InvocationID == 0){
        gl_TessLevelInner[0] = 10.0;
        gl_TessLevelOuter[0] = 10.0;
        gl_TessLevelOuter[1] = 10.0;
        gl_TessLevelOuter[2] = 10.0;
    }

    gl_out[gl_InvocationID + (10*houseNum)].gl_Position = gl_in[gl_InvocationID].gl_Position;

    float houseX, houseY, houseWallH;
    vec4 posA, posB, posBp, posC, posCp, posD, posDp, posE, posEp, posF, posFp;

    //============================
    //na ka¿dy domek wysy³amy dalej wszystkie wymagane wierzcho³ki. Oznacza to, ¿e potrzebnych ich jest 10 - bez punktu centalnego domu. W tym miejscu z niego korzystamy i nie ma sensu go dalej przekazywaæ
    for(int i = 0; i < houseNum; i++)
    {
        posA = vec4(HouseCoord_CS_in_F[i].x, HouseCoord_CS_in_F[i].y, HouseCoord_CS_in_F[i].z, 1.0);
        posB = vec4(HouseCoord_CS_in_S[i].x, HouseCoord_CS_in_S[i].y, HouseCoord_CS_in_S[i].z, 1.0);

        houseX = posA.x-posB.x;
	    houseY = posA.y-posB.y;
        houseWallH = HouseCoord_CS_in_S[i].w;

        posBp = vec4(posA.x - houseX, posA.y - houseY, posA.z, 1.0);
        posC = vec4(posA.x - houseX, posB.y, posA.z, 1.0);
        posCp = vec4(posB.x, posA.y - houseY, posA.z, 1.0);

        posD = vec4(posB.x, posB.y, posB.z + houseWallH, 1.0);
        posDp = vec4(posBp.x, posBp.y, posBp.z + houseWallH, 1.0);
        posE = vec4(posC.x, posC.y, posC.z + houseWallH, 1.0);
        posEp = vec4(posCp.x, posCp.y, posCp.z + houseWallH, 1.0);

        posF = vec4(posA.x, posB.y, posA.z + 1.5*houseWallH, 1.0);
        posFp = vec4(posA.x, posBp.y, posA.z + 1.5*houseWallH, 1.0);

        gl_out[gl_InvocationID + (10*i) + 0].gl_Position = posB;
        gl_out[gl_InvocationID + (10*i) + 1].gl_Position = posBp;
        gl_out[gl_InvocationID + (10*i) + 2].gl_Position = posC;
        gl_out[gl_InvocationID + (10*i) + 3].gl_Position = posCp;
        gl_out[gl_InvocationID + (10*i) + 4].gl_Position = posD;
        gl_out[gl_InvocationID + (10*i) + 5].gl_Position = posDp;
        gl_out[gl_InvocationID + (10*i) + 6].gl_Position = posE;
        gl_out[gl_InvocationID + (10*i) + 7].gl_Position = posEp;
        gl_out[gl_InvocationID + (10*i) + 8].gl_Position = posF;
        gl_out[gl_InvocationID + (10*i) + 9].gl_Position = posFp;
    }

}
